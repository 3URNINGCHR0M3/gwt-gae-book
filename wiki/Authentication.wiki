#summary Authentication with OpenID

<wiki:toc max_depth="2" />

<img src="http://gwt-gae-book.googlecode.com/svn/wiki/images/vintage_keys.jpg" border="0"  align="right" />

Although it's possible to develop App Engine applications with custom authentication (e.g. using your own username/password lookup, or by connecting to custom 3rd party web services), we'll focus on OpenID.

= Signing in using OpenID =
*Pre-requisites*

 * [http://en.wikipedia.org/wiki/OpenID OpenID introduction]
 * [http://code.google.com/appengine/docs/java/users/overview.html AppEngine Users Java API overview]
 * [http://code.google.com/intl/nl-NL/appengine/articles/openid.html Using federated authentication via OpenID]

Here are the steps to add authentication support
 # define [http://code.google.com/p/gwt-gae-book/source/browse/trunk/CultureShows/src/org/gwtgaebook/CultureShows/shared/model/UserInfo.java UserInfo] model, used to send user information from server to client 
 # define !GetUser [http://code.google.com/p/gwt-gae-book/source/browse/trunk/CultureShows/src/org/gwtgaebook/CultureShows/shared/dispatch/GetUser.java action/result generator] and [http://code.google.com/p/gwt-gae-book/source/browse/trunk/CultureShows/src/org/gwtgaebook/CultureShows/server/dispatch/GetUserHandler.java handler], [http://code.google.com/p/gwt-gae-book/source/browse/trunk/CultureShows/src/org/gwtgaebook/CultureShows/server/MainHandlerModule.java bind them]. !GetUserHandler.java contains
{{{
	public GetUserResult execute(GetUserAction action, ExecutionContext context)
			throws ActionException {

		UserInfo userInfo = new UserInfo();

		UserService userService = UserServiceFactory.getUserService();
		User user = userService.getCurrentUser();

		if (user != null) {
			userInfo.isSignedIn = true;
			userInfo.signOutURL = userService.createLogoutURL(action
					.getRequestURI());
			userInfo.email = user.getEmail();
			userInfo.userId = user.getUserId();
		} else {
			userInfo.isSignedIn = false;
			userInfo.signInURLs.put("Google", userService.createLoginURL(action
					.getRequestURI(), null, "google.com/accounts/o8/id", null));
			userInfo.signInURLs.put("Yahoo", userService.createLoginURL(action
					.getRequestURI(), null, "yahoo.com", null));
		}

		return new GetUserResult("", userInfo);
}
}}}
 # in `LandingPage` presenter, get user info from server
{{{
		dispatcher.execute(new GetUserAction(Window.Location.getHref()),
				new DispatchCallback<GetUserResult>() {
					@Override
					public void onSuccess(GetUserResult result) {
						if (!result.getErrorText().isEmpty()) {
							// TODO have a general handler for this
							Window.alert(result.getErrorText());
							return;
						}
						setUserInfo(result.getUserInfo());
					}
				});
...

	public void setUserInfo(UserInfo userInfo) {
		this.userInfo = userInfo;
		getView().setSignInOut(userInfo);
	}
}}}
 # in `LandingPage` View have a basic UI for signing in/out
{{{
	@UiField
	HTML signInOut;

	public void setSignInOut(UserInfo userInfo) {
		String html;
		if (userInfo.isSignedIn) {
			html = userInfo.email + " | " + "<a href='" + userInfo.signOutURL
					+ "'>Sign Out</a>";
		} else {
			html = "<a href='" + userInfo.signInURLs.get("Google")
					+ "'>Sign In with Google</a>" + " | " + "<a href='"
					+ userInfo.signInURLs.get("Yahoo")
					+ "'>Sign In with Yahoo</a>";

		}
		signInOut.setHTML(html);

	}
}}}

It's really that easy. The result?

_Signed out_ <br/>
<img src="http://gwt-gae-book.googlecode.com/svn/wiki/assets/signedOut.png" border="1"  />

-----

_Signing in with Google_ <br/>
<img src="http://gwt-gae-book.googlecode.com/svn/wiki/assets/signingInG.png" border="1"  />

-----

_Signed in with Google_ <br/>
<img src="http://gwt-gae-book.googlecode.com/svn/wiki/assets/signedInG.png" border="1"  />

-----

_Signing in with Yahoo_ <br/>
<img src="http://gwt-gae-book.googlecode.com/svn/wiki/assets/signingInY.png" border="1"  />

-----

_Signed in with Yahoo_ <br/>
<img src="http://gwt-gae-book.googlecode.com/svn/wiki/assets/signedInY.png" border="1"  />


App Engine supports more !OpenID providers. To keep the UI usable, we'll limit the options to the most popular two.

= Updating UI to accommodate authentication =

As you keep adding functionality, you also need to consider what are the final goals you need to reach with your app and consider refactoring in order to better support those goals (be careful not to [http://en.wikipedia.org/wiki/Overengineering overengineer] it).

== Goals ==
What are the goals we're trying to accomplish?
 * have multiple places (such as Landing page), each with the same header
  * some accessible by anonymous users (e.g. Landing page, About Culture Shows)
  * some restricted to signed in users, and maybe with some specific permissions
 * sometimes content depends on user signed in state or permissions (e.g. header will show Sign In or Sign Out links)
 * app can be initialized from any place, not just the default (if somebody bookmarked it or hits browser refresh)
 * sign in/out can be triggered from any place, should return to that place 
 
<img src="http://gwt-gae-book.googlecode.com/svn/wiki/images/architecture.jpg" border="0"  align="right" />

== Refactoring ==

Let's introduce a Main presenter, which will contain a Header widget and a Main content placeholder. All relevant contents from Landing are moved to these new entities, leaving here just show scheduling.
Here's the [http://code.google.com/p/gwt-gae-book/source/detail?spec=svn372&r=372 full refactoring changelist].

== Custom widgets & events ==
*Pre-requisites*
 * [http://arcbees.wordpress.com/2010/08/24/gwt-platform-event-best-practice/ Custom events with gwt-platform]

We were already getting user info and setting the header depending on user state. There are more places though which depend on it, e.g. Sign In button on the right of Landing page. We'll let Main presenter initiate getting user info, and when that's received fire a [http://code.google.com/p/gwt-gae-book/source/browse/trunk/CultureShows/src/org/gwtgaebook/CultureShows/client/event/UserInfoAvailableEvent.java UserInfoAvailableEvent] :

{{{

	@Override
	protected void onBind() {
		super.onBind();

		dispatcher.execute(new GetUserAction(Window.Location.getHref()),
				new DispatchCallback<GetUserResult>() {
					@Override
					public void onSuccess(GetUserResult result) {
						if (!result.getErrorText().isEmpty()) {
							Window.alert(result.getErrorText());
							return;
						}
						setUserInfo(result.getUserInfo());
					}
				});

	}

	public void setUserInfo(UserInfo userInfo) {
		this.userInfo = userInfo;
		UserInfoAvailableEvent.fire(this, userInfo);
	}
}}}

Interested parties can listen to this event and handle it as desired. For example, the Header will do
{{{
	@Override
	protected void onBind() {
		super.onBind();

		addRegisteredHandler(UserInfoAvailableEvent.getType(),
				new UserInfoAvailableHandler() {
					@Override
					public void onHasUserInfoAvailable(
							UserInfoAvailableEvent event) {
						setSignInOut(event.getUserInfo());

					}
				});
	}

	public void setSignInOut(UserInfo userInfo) {
		getView().setSignInOut(userInfo);
	}

}}}


<img src="http://gwt-gae-book.googlecode.com/svn/wiki/images/vis_3.jpg" border="0"  align="right" />

=== Exercise ===
Change Landing so it displays Sign In button only if user is not signed in.

=== Exercise solution ===
[http://code.google.com/p/gwt-gae-book/source/detail?spec=svn376&r=376 Changelist]

= Enhancing sign in experience =
Here are some goals for a better sign in experience:
 * have a nice Sign In dialog
 * allow triggering Sign In from various places
 * ideally, load Sign In code & images only when required, in order to keep the initial download size small 

We'll achieve this by
 * introducing a [http://code.google.com/p/gwt-gae-book/source/browse/trunk/CultureShows/src/org/gwtgaebook/CultureShows/client/widget/ Sign In widget]
 * introducing a [http://code.google.com/p/gwt-gae-book/source/browse/trunk/CultureShows/src/org/gwtgaebook/CultureShows/client/event/SignInEvent.java Sign In event], handled by `MainPresenter`
{{{
		addRegisteredHandler(SignInEvent.getType(), new SignInHandler() {
			@Override
			public void onHasSignIn(SignInEvent event) {
				showSignInDialog();

			}
		});
...
	public void showSignInDialog() {
		signInPresenter.setUserInfo(userInfo);
		RevealRootPopupContentEvent.fire(this, signInPresenter);
	}

}}}
 * making the Header and Landing fire the Sign In event on user request, e.g.
{{{
@UiHandler("signIn")
        void onSignInClicked(ClickEvent event) {
                getUiHandlers().requestSignIn();
        }
...
	public void requestSignIn() {
		SignInEvent.fire(this);
	}

}}}

Here's the result:

<img src="http://gwt-gae-book.googlecode.com/svn/wiki/assets/signInWidget.png" border="0" />

TODO: somebody please style the !SignIn widget to look better and send your changes to be included here.

See [http://code.google.com/p/gwt-gae-book/source/detail?spec=svn400&r=400 full changelist].

= Code splitting =
*Pre-requisites*
 * [http://code.google.com/webtoolkit/doc/latest/DevGuideCodeSplitting.html Code splitting]
 * [http://jcheng.wordpress.com/2010/02/16/elegant-code-splitting-with-gwt/ Elegant code splitting]


Loading Sign In code & images separately can be done in a basic way with these changes to `MainPresenter` :

{{{
	private final AsyncProvider<SignInPresenter> signInPresenterAP;

	@Inject
	public MainPresenter(... ,
		final AsyncProvider<SignInPresenter> signInPresenterAP) {
		...
		this.signInPresenterAP = signInPresenterAP;

	}

	public void showSignInDialog() {

		signInPresenterAP.get(new AsyncCallback<SignInPresenter>() {

			@Override
			public void onSuccess(SignInPresenter signInPresenter) {
				showSignInDialogNow(signInPresenter);
			}

			@Override
			public void onFailure(Throwable reason) {
				// TODO Auto-generated method stub

			}
		});
	}

	public void showSignInDialogNow(SignInPresenter signInPresenter) {
		setUserInfo(userInfo);
		RevealRootPopupContentEvent.fire(this, signInPresenter);
	}

}}}

This reduced the initial download from 76kb to 71kb, downloading in a second phase another 10kb. The savings are not that big, so we'll leave this optimization out for now.

= Migrating stored anonymous data to signed in users =

== Guice Providers == 
Since we'll start needing user info on more calls on server, we'll introduce a [http://google-guice.googlecode.com/svn/trunk/javadoc/com/google/inject/Provider.html Guice Provider] for it :
{{{
public class UserInfoProvider implements Provider<UserInfo> {

	public UserInfo get() {
		UserInfo userInfo = new UserInfo();

		UserService userService = UserServiceFactory.getUserService();
		User user = userService.getCurrentUser();

		if (user != null) {
			userInfo.isSignedIn = true;
			userInfo.email = user.getEmail();
			userInfo.userId = user.getUserId();
		} else {
			userInfo.isSignedIn = false;
		}

		return userInfo;
	}
}

}}}

The Handler constructors will be called only once per instance, not once per request. Since we need fresh user info on each request to see if the user is actually signed in or not, unlike !ObjectDatastore, we'll inject the provider this time and get user info manually in execute() :
{{{
	@Inject
	public GetUserHandler(final Provider<UserInfo> userInfoProvider,
			final ObjectDatastore datastore) {
		super(userInfoProvider, datastore);
	}

	@Override
	public GetUserResult execute(GetUserAction action, ExecutionContext context)
			throws ActionException {

		UserInfo userInfo = userInfoProvider.get();
		...
	}
}}}


== Design of handling both anonymous and authenticated users ==
We'll need to change `GetUserHandler` to handle anonymous users, authenticated users and migrating data from anonymous to authenticated if needed. We'll let the client always set whatever `UserToken` is returned by `GetUserHandler` and have the logic for setting it on the server.

We also need to update `LandingPresenter` to get performances both on presenter reveal (e.g. returning to landing page from another place in app) and on `UserInfoAvailableEvent`. Scheduling performances is pretty much ok as it is now, since we designed with this use case in mind.

So what are the use cases which need to handled by `GetUserHandler`?
 * anonymous user: preserve token if given, otherwise generate a token
 * returning anonymous user, has performances - need to know theaterKey (assuming it won't be in cookie anymore)
 * anonymous user which has performances, but is also registered and has performances as registered member too
 * user signed in with `UserToken` set (need to update member data)
 * user signed in, without `UserToken` set


With this in mind, the pseudocode for `GetUserHandler` could be like this:
{{{
userTokenOut = null

if userToken not empty
	find member where userId = "anonymous" + userToken
	if member exists
		// has a member record from anonymous usage
		// does he have a previous registered member too? if yes, merge anonymous data into registered
		if isSignedIn
			find signedInMember
			if found
				update tmjs to signedInMember
				delete anonymousMember
			else
				update member set userId


if isSignedIn && null = member
	find member by userId
	

if (null != member)
	get theaters member has access to		

if (!isSignedIn)
	if userToken
		userTokenOut = userToken
	else
		userTokenOut = random
}}}


What do think? Yep, it starts getting messy and very prone to bugs. Just like real-life projects :) You need to continuously watch out for situations like this. It's good we realize the complexity from pseudocode, rather than from written and debugged code. Rather than getting absorbed in delivering, let's step back for a moment and see if we can [http://en.wikipedia.org/wiki/KISS_principle keep it simple].

== Refactoring of... requirements! ==
To simplify, we need to introduce some constraints.

=== Exercise two ===
Think what constraints can we introduce in our requirements.

=== Exercise two solution ===
We could simplify a little by always having a Member record for signed in users. Maybe we could have all the `UserToken` logic in `ScheduleShowHandler`, since we don't need it if there are no performances saved, right? Or we could move all the anonymous user handling on the client, and on signing in just save the data. Still not simple enough.

What was the reason we let Violeta schedule shows without being signed in? To lower the user entry barrier. Well, with OpenID, that barrier is just two mouse clicks high: sign in and authorize our app. Let's do this:
 * allow only signed in users to schedule shows
 * let anonymous users fill the landing page data, but on 'Schedule show' prompt them to sign in. When coming back to app after signing in, save the data for them.
 
= Updated application design =
So our first approach wasn't the best possible. Probably this re-design isn't perfect either, but as long as it's better than the initial one, we're good. Let's create [http://code.google.com/p/gwt-gae-book/source/browse/#svn/branches/CultureShows-allow-anonymous-scheduling/CultureShows a branch] with old code, [http://code.google.com/p/gwt-gae-book/downloads/detail?name=CultureShows-allow-anonymous-scheduling.tgz&can=2&q= an archive], and move on! All stories in our [http://code.google.com/p/gwt-gae-book/wiki/SoYouHaveAnIdea#Culture_Shows_product_backlog_(for_real) backlog] remain valid.


== !GetUserHandler pseudocode ==
{{{
get userInfo
if isSignedIn
	get signOutURL
	check if user has a Member record, create one if not
	get theaters member has access to
else
	get signInURLs
}}}

== !MainPresenter pseudocode ==
{{{
request GetUser

on GetUserSuccess
	set UserInfo, including 
		theaters member has access to
		currentTheaterKey (first from the list)
	UserInfoAvailableEvent.fire
}}}


== !LandingPresenter pseudocode ==
{{{
on ScheduleShow request
	if isSignedIn
		make the server request
	else
		save Performance data in cookie so it is available on user return 
		ask user to sign in instead of making the server request

onUserInfoAvailable
	getView.setSignInOut

	if user isSignedIn
		if Performance data exists in cookie
			request ScheduleShow //it will add to currentTheaterKey if set
			remove Performance data in cookie
		if theaterKey is set
			request GetPerformances

on ScheduleShowSuccess
	set theaterKey returned by server
}}}



== !ScheduleShowHandler pseudocode ==
{{{
//called only when user isSignedIn
//data received from client: theaterKey (may be empty), date, showName, locationName

load member record, exception if it does not exist

// setup theater
if (theaterKey is not empty) {
	load theater //might not exist, key may be invalid
	if (null == theater) {
		theaterKey = null	
	} else {
		verify memberKey has access to theater, exception if not
	}
}

if (theaterKey is empty) {
	create theater instance
	theaterKey = store(theater)
	assign member to theater with role administrator
}

// setup show
showKey = find(showName assigned to theaterKey)
if (showKey is empty) {
	create and store show with parent=theater 
}

// setup location...

store(performance)

return theaterKey, performanceMap
}}}

For implementation, see [http://code.google.com/p/gwt-gae-book/source/browse/trunk/CultureShows/src/org/gwtgaebook/CultureShows/ latest source code].

<wiki:comment>NAV_START</wiki:comment>
<a href='http://code.google.com/p/gwt-gae-book/issues/entry'><img src='http://gwt-gae-book.googlecode.com/svn/wiki/assets/envelope.png' border='0' title='Send feedback' /></a>
<img src='http://gwt-gae-book.googlecode.com/svn/wiki/assets/spacer.png' border='0' />
<a href='http://code.google.com/p/gwt-gae-book/wiki/StoringData'><img src='http://gwt-gae-book.googlecode.com/svn/wiki/assets/prev.png' border='0' title='Previous chapter: Saving schedule in datastore' /></a>
<a href='http://code.google.com/p/gwt-gae-book/wiki/TableOfContents'><img src='http://gwt-gae-book.googlecode.com/svn/wiki/assets/contents.png' border='0' title='Table Of Contents' /></a>
<a href='http://code.google.com/p/gwt-gae-book/wiki/ListingSchedule'><img src='http://gwt-gae-book.googlecode.com/svn/wiki/assets/next.png' border='0' title='Next chapter: Listing saved schedule' /></a>
<wiki:comment>NAV_END</wiki:comment>