#summary Are you using the right tool for the job?

<wiki:toc max_depth="2" />

Before settling on GWT and GAE, ask yourself if they are the best fit for your project. 
 * what are your needs? 
 * what are the alternatives you have? how do they compare?


= Analysis of using GWT for a large UI project =

This is an analysis done in 2010 for a large project which has a .NET back-end, with REST APIs (transport: XML and JSON). We control the back-end. We're looking for a framework to replace the current UI. 

<img src="http://gwt-gae-book.googlecode.com/svn/wiki/images/journey.jpg" border="0"  align="right" />

== Goals ==

 * clean architecture: separation of presentation from behavior
 * automatically testable (not just Selenium, but also unit tests, jmeter etc)
 * ease of developing new features - evaluate amount of work implied on adding a new feature or changing an existing one
 * ease of adoption by all engineering team (programming language, documentation / learning materials, development environment setup)
 * ease of integration with other frameworks & components (e.g. jQuery, tinyMCE)
 * multi-screen/multi-device/touch support - either out of the box, or easy to add, but not blocker
 * ease of integrating with 3rd party services 
 * widgets available, with easy skinning
 * i18n support


== Web applications paradigm alternatives ==


When developing web applications, you can choose to expose the front end functionality in more ways:
 * heavily coupled with back-end (e.g. Java/PHP/ASP back-end will generate the required HTML/JS/CSS). In this case it’s strongly recommended to use architectures such as MVC and template libraries, in order to reduce coupling.
 * over web service APIs (REST or RPC), and have the front-end communicate with back-end via APIs.

<img src="http://gwt-gae-book.googlecode.com/svn/wiki/images/father_and_child.jpg" border="0"  align="right" />

The latter approach has a few interesting advantages
 * clean architecture (separation of UI from back-end is forced). You might have additional MVP architecture layers on front-end (front-end Model is different than back-end Model, e.g. you might have fields stored in multiple tables and expose all under a single entity in API)
 * easier testing automation (unit testing for back-end; functional & performance testing over APIs; unit testing and automated browser testing for front-end)
 * easier to debug by blackbox QEs (e.g. just by using Firebug, they can determine the cause for an issue: back-end business logic or front-end)
 * decoupling of front-end from back-end. Simpler deployment, easy rollbacks, simpler overall project maintenance (specific example: all project build/database broken impeds all teams work; back-end project build broken will allow front-end development to continue using any available deployment)
 * easily allows simultaneous multiple UI versions in production. After deploying a new release (back-end and front-end), you can switch on the new front-end release separately by flipping a switch. You can also do gradual activation for UI features (e.g. activate it for only 10% of the customers and get feedback before activating it to all) and easily do A-B testing  
 * no technology constraints for front-end clients. Use the right tool for the specific job you need
 * APIs will be available for other clients, making you ready for scalable growth. You can have web apps, native mobile clients, native desktop clients and 3rd party services integration, all on top of the same APIs
 * you're no longer the only kid on the block, and one size doesn't fit all. Current web apps need to consider integrating to other services (think social, or a photo editor/print service). When integrating with these, you'll use same patterns as in your app. Often your back-end server doesn't need to interact with the 3rd party service at all, only the front-end client will need to know how to work with them. Example: if your users can to upload photos to your website and you develop an API for this, the client can latter be enhanced to allow users to select photos from Picasa/Flickr/Facebook rather than just their hard-drive. Unless you also want to save Picasa user account information, the back-end doesn’t need to be touched to implement this functionality
 * significantly less bandwitdth/CPU/memory requirements for servers
 * better user experience. Faster response time, update only specific parts of the page instead of full page reload on user actions

    
Disadvantages: 
 * (perceived) you need APIs for almost every feature exposed to front-end, which might be perceived as more work. You'd have to build that functionality anyway, and using APIs forces you to think about separation of UI from back-end. You should also have an API layer which takes care of all common functionality (e.g. authentication, logging) rather than doing this individually for each API.


== Google Web Toolkit (GWT) ==


GWT has quite a few good points, and some areas where it could do better. Let’s look at it from several perspectives.

=== Engineering ===

<img src="http://gwt-gae-book.googlecode.com/svn/wiki/images/alone.jpg" border="0"  align="right" />

Good:
 * [http://code.google.com/webtoolkit/makinggwtbetter.html#introduction has Google behind it], and Google knows how to build web apps
 * mature (1st release on May 2006), has many libraries available (e.g. [http://code.google.com/hosting/search?q=gwt&projectsearch=Search+projects code.google.com], [http://sourceforge.net/search/?type_of_search=soft&words=gwt sourceforge]) 
 * growing set of functionality (Roo, Data Presentation Widgets, GWT Designer)
 * generates optimized, cross-browser JS
 * automatically manages compressing JS, CSS, [http://code.google.com/webtoolkit/doc/latest/DevGuideClientBundle.html building image sprites] => reduced # of HTTP requests
 * rich ecosystem of powerful tools and libraries, compared to JS (debugging in browser code written in Java, IDEs, auto-completion, static code analysis tools, design patterns, unit testing and code coverage, most of these open source) => increased productivity
 * enables caching most of all client side (vs. fully loading each page on a request) (faster, save bandwidth costs)
 * all client (compiled JS/CSS/images) can be deployed on a CDN
 * code splitting of generated JS (dynamically load only needed parts)
 * [http://code.google.com/webtoolkit/articles/testing_methodologies_using_gwt.html built-in unit testing support] (including asynchronous calls)
 * build in support for automated browser testing (flag to include field ids or not in generated HTML markup)
 * powerful i18n support (including automatic extraction of strings)
 * native HTML5 support almost ready (e.g. [http://code.google.com/p/gwt-mobile-webkit/ storage, offline web apps])
 * mobile/iDevice friendly (e.g. [http://clay.lenharts.net/blog/2009/05/25/gwt-is-flexible-iphone-demo/ iPhone], [http://development.lombardi.com/?p=1346 multi-touch demo], [http://m.geotako.com/ sample app])
 * can be easily integrated with AJAX frameworks such as jQuery, YUI (there’s even a [http://code.google.com/events/io/2009/sessions/ProgressivelyEnhanceAjaxApps.html jQuery port to GWT])
 * easy to develop new custom widgets
 * !UiBinder model (separate display from behavior)
 * native MVP support 
 * REST support
 * [http://code.google.com/webtoolkit/doc/latest/DevGuideA11y.html accessibility support]

<img src="http://gwt-gae-book.googlecode.com/svn/wiki/images/lemon.jpg" border="0"  align="right" />
A particular advantage over ASP.NET is availability of many mature tools & libraries which are free and open source (from unit testing and mocks builder frameworks, to static code analysis). Even if cost is not an issue, for engineering this translates to
 * immediate availability (specific example - we needed a memory profiler during a sprint, had to involve a program manager and find a license from another developer which wasn’t using it at that time)
 * support (community vs paid). For larger open source projects, there is free support provided by users and developers for that tool/library. This is offered by community for pleasure of learning and helping others, and is much better compared to many commercial products. [http://groups.google.com/group/gwt-platform/browse_thread/thread/6eee2e443cd408c9# Here’s one support example while learning GWT], [http://groups.google.com/group/piriti/browse_thread/thread/7d0c276e8cfcfcf8 one more example]
 * public design discussions - how should things work in the next versions? This allows many opportunities to contribute with feedback according to specific project needs. Senior engineers on your team can continue to grow their architecture skills by learning and contributing to these discussions, while happily working to the same project. [https://wave.google.com/wave/#restored:wave:googlewave.com%252Fw%252Beva-sERfA.1 An example], [https://wave.google.com/wave/#restored:wave:googlewave.com%252Fw%252BEI8yh67GA another example], [http://groups.google.com/group/gwt-platform/browse_thread/thread/1cf3efb5780e5b80/a5596a47a9be07d7 one more example].


Not so good:
 * introduces a new technology (Java) to the team, a new IDE. However, that’s why we hire good software engineers, not good C++/PHP developers. Either way the team needs to learn to work with new paradigms (e.g. ASP.NET MVC) and use new tools (e.g. building and using image sprites to minimize number of HTTP calls, profiling tools, unit testing frameworks)
 * one-time setup of build system. If not using GWT, we need additional tools anyway for JS compiling and image bundles building
 * some widgets have tagsoup
 * sometimes you need to write boilerplate code to achieve a functionality (e.g. make a REST call)
 * missing powerful widgets (e.g. [http://www.smartclient.com/smartgwt/showcase/#tiling_filter_sort SmartGWT’s TileGrid]). Reason: GWT is a toolkit, enabling others to write libraries for it, not a full all-in-one solution for web apps development. There are many 3rd party widget libraries


=== Cross-functional team collaboration ===

A large web app it’s built by a large cross-functional team. We have blackbox and whitebox QEs, user experience designers, graphic designers, product managers and support. How does GWT benefit them?

<img src="http://gwt-gae-book.googlecode.com/svn/wiki/images/horse-drawn.jpg" border="0"  align="right" />

==== Scrum teams ====
We use Scrum with 4 week sprints and apply Scrum best practices such as splitting large stories in small ones. While we try to work on stories in order of priority, we still reach the last sprint week with most stories not done as we cannot fully parallelize effort to work on one story at a time.

 * multiple developers will be able to work on the same story (one or two back-end, one front-end using mock data models, which have to be built anyway for unit testing)
 * early development of functional front-end with mock data models. Black box QEs will be able to do early QA on user workflows and usability, rather then at the sprint end when it’s usually too late to do major changes. Specific example: we had a large feature developed and released, which is working mostly ok from functionality point of view, but had large usability issues raised by customers.
 * white box QAs can write API tests as soon as the data model is agreed, and can review and contribute to front-end unit testing (both with mock Views, which tests the Presenter logic, and with real Views, which tests browser functionality).
 * rapid development on integrating separate workflows. If we already fully developed two separate workflows, to integrate them we need to change only the client. Example: If you have a front-end to post a Wordpress blog entry which includes images, and you also have a separate photo gallery management section in the same application, you only need to update the client to enable drag and dropping photos from your photo galleries into a blog post.


<img src="http://gwt-gae-book.googlecode.com/svn/wiki/images/stone_tower.jpg" border="0"  align="left" />

==== User experience designers and graphic designers ====

With the current process, UX designers develop wireframes and some high resolution mockups for larger features. Then they don’t interact at all with the end result until it’s completed by the team. Feedback from UX is sometimes integrated in the next sprint, sometimes not considered as the story it’s done and we need to continue working on other features.

Using GWT will allow the team to rapidly develop early UIs, with mock data models. UX team will be able to see their proposed workflows in action during the actual feature development. As GWT separates not only logic from presentation with MVP, but also [http://code.google.com/webtoolkit/doc/latest/DevGuideUiBinder.html HTML/CSS markup from Java code], UX folks are able to make changes themselves to markup, CSS and widgets, and submit their final changes directly into the version control system, again during the feature development (we are using Continuous Integration). Front-end unit tests developed by engineering team make sure they don’t break anything.

==== Product managers and support ==== 
<img src="http://gwt-gae-book.googlecode.com/svn/wiki/images/against_light.jpg" border="0"  align="right" />
Product managers and support get to see the features developed by the team late in the sprint, sometimes even at the sprint demo for the first time. These groups always have valuable feedback from the customer and integration with larger system point of views. By *enabling them to deliver the feedback early during the sprint*, we enable the team to integrate it until the story is done.

On several releases we also had important issues raised by customers right after release, forcing us sometimes to do painful rollbacks while affecting users. Using GWT for front-end allows us to have multiple, simultaneous front-end versions in production. After doing a back-end release with newer versioned APIs added, we can *roll out front-end gradually to users* and get feedback before enabling the updated functionality for all. In case of issues (and nobody is perfect), this lowers the support costs and keeps up the company brand image. If there are issues with new back-end API versions, we keep them again under control by fast switching to an earlier front-end release, which uses older APIs.

An interesting benefit of having multiple, simultaneous front-end versions in production is that we can *easily do A/B testing on various features*. With proper metrics in place, product managers and UX designers can get valuable data about how customers actually use features and what alternatives are better than others.

==== Operations ====
A GWT front-end is just a set of cachable HTML/JS/CSS/images static files, which transfer data using JSON REST requests. Compared to ASP.NET, this results in *significantly reduced datacenter costs (bandwidth, CPU, memory)*. 
*Deployment is easier*, and rolling back to a different front-end release is just flipping a switch.

<img src="http://gwt-gae-book.googlecode.com/svn/wiki/images/leaves.jpg" border="0"  align="right" />

== More info on GWT ==

[http://fredsa.allen-sauer.com/2009/10/sf-jug-gwt-can-help-you-create-amazing.html GWT Can Help You Create Amazing Web Apps]

[http://www.scribd.com/doc/44602/Google-Web-Toolkit GWT Intro]

[http://code.google.com/events/io/2010/sessions/architecting-production-gwt.html Architecting GWT applications for production at Google]

[http://code.google.com/events/io/2010/sessions/gwt-continuous-build-testing.html GWT testing best practices]

[http://code.google.com/events/io/2009/sessions/GoogleWebToolkitBestPractices.html Best Practices For Architecting Your GWT App]

[http://code.google.com/webtoolkit/articles/mvp-architecture.html MVP architecture for GWT]


== Recommendation ==

Besides GWT, we looked at various other frameworks, including Sproutcore, Capuccino, ASP.NET with MVC and ASP.NET AJAX (documented these internally).
GWT has many advantages and fits our needs. 

Next step: deep dive on ASP.NET with MVC.

GWT specific next steps: test deployment, research how easy is using CSS and external JS, research overwriting generated markup for some widgets or building more complex widgets from scratch if needed, review top open bugs to see how stable/maintained GWT is (we cannot do the same with ASP :)

<img src="http://gwt-gae-book.googlecode.com/svn/wiki/images/learning_with_pencil.jpg" border="0"  align="left" />
For feedback on this document, please contact Marius.Andreiana @ gmail.com. Thanks to the GWT discussion group and other folks, who already provided valuable feedback.


== Appendix: Evaluating GWT 3rd party libraries ==

GWT has many 3rd party libraries, covering areas such as widgets, validation, logging, charts and even equation editors. A few of the widget libraries chose to heavily use Javascript and their own widget model to implement various widgets (e.g. SmartGWT), leading to various issues: [http://forums.smartclient.com/showthread.php?p=15141 layout], performance, some incompatibility with native GWT widgets. I recommend not using this kind of libraries and stick to widgets built on the GWT model, including [http://code.google.com/webtoolkit/doc/latest/DevGuideUiBinder.html UiBinder].


== Appendix: GWT apps at Google ==
http://adwords.google.com/

http://www.google.com/profiles

http://www.google.com/squared

http://www.google.com/moderator/

http://wave.google.com/

http://www.orkut.com/

Mobile Maps and Latitude for iPhone


"We use Google Web Toolkit for all our Java-based internal apps," said Google CIO Ben Fried. "It's a great tool for Enterprise-class Java GUI development, and we build our most sensitive and critical corporate systems with it. In addition to the big benefits in developer productivity GWT offers, the future-proofing and browser independence you get out of the box mean that we're protected from the problems caused by browser-specific bugs and exploits."



== Appendix: Cool GWT apps ==


[http://smist08.wordpress.com/2009/12/03/the-sage-erp-accpac-6-0a-portal/ Sage ERP Portal]

http://www.studyblue.com/

[http://www.yesmail.com/Products/Platforms/Yesmail-Enterprise.aspx Yesmail] 
([http://www.youtube.com/watch?v=DPchEb6Pz-c demo], [http://devcenter.yesmail.com/com.yesmail.magellan.gwt.rolodexdemo.RolodexDemoApp/RolodexDemoApp.html sample widget]) 

http://www.zackgrossbart.com/hackito/spiffy/

[http://www.sambajam.com/signup SambaJAM] ([http://www.youtube.com/user/sambastream#p/a/u/1/izUeOhLxLpg video])

http://beta.contactoffice.com/

http://riflethru.com/ (both desktop and mobile UIs)

http://www.appbrain.com/

http://jboss.org/drools/drools-guvnor.html

[http://james.apache.org/hupa/screenshots.html Apache Hupa IMAP mail client]

<img src="http://gwt-gae-book.googlecode.com/svn/wiki/images/old_boat.jpg" border="0"  align="right" />

== Appendix: Deployment Setup ==

We have api.backend.com, which offers REST APIs over SSL such as:
{{{
POST /login
Body: data username, password
Response: authToken

GET /tweets
Authorization: authToken (Custom HTTP Header)
Body: none
Response: tweets
}}}

*Production*

Deploy app.html on api.backend.com which loads compiled JS from CDN. app.html is loaded in an iframe from wherever is needed to avoid SOP restrictions on all browsers.

*Development environment for folks doing client-only development*

api.backend.com will return on all requests the header
{{{
Access-Control-Allow-Origin: *
Access-Control-Allow-Headers: Authorization
}}}
so that the UI can be served from frontend.com and other domains, but still access the APIs
(same origin policy). There won't be anything else on api.site.com besides stateless APIs (no cookies, no html files).
User navigates to frontend.com. The UI gets username & password, passes it to api.backend.com, then it will store authToken and use it on all further requests (same as a cookie stores session id on other systems).

This setup should be fully secure for production too, but we cannot use it as Internet Explorer doesn’t support properly Access-Control-Allow-Origin with XHR (has a separate proprietary object, XDomainRequest, for this use case).

<img src="http://gwt-gae-book.googlecode.com/svn/wiki/assets/envelope.png" border="0"  /><a href="http://code.google.com/p/gwt-gae-book/issues/entry">Send feedback</a>