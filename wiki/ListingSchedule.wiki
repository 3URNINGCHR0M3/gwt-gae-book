#summary Listing saved schedule

<wiki:toc max_depth="2" />

Until now, we used the local datastore viewer to see what data is saved. Well, it's time to let Violeta see it too.

<img src="http://gwt-gae-book.googlecode.com/svn/wiki/images/rencontres_1.jpg" border="0"  align="right" />

= A quick, basic solution =
Our basic need is to have a client doing [http://en.wikipedia.org/wiki/Create,_read,_update_and_delete CRUD] operations on Performance entity items. We just covered Create, moving on to Read.

In order to quickly get the latest schedule data and display it on client, we can 
 # get all items when page loads
 # when adding/updating/deleting items, send changes from client to server and if response is successful update the client list too

== Exercise ==
Implement listing added performances. Hints:
 * remember [ClientServer#Summary client-server communication]
 * no need to check access, performances are public
 * use a HTMLPanel to display data. We'll enhance this later

== Exercise solution ==
Added [http://code.google.com/p/gwt-gae-book/source/browse/trunk/CultureShows/src/org/gwtgaebook/CultureShows/shared/dispatch/GetPerformances.java GetPerformances] Action/Result generator, and [http://code.google.com/p/gwt-gae-book/source/browse/trunk/CultureShows/src/org/gwtgaebook/CultureShows/server/dispatch/GetPerformancesHandler.java GetPerformancesHandler]

`ScheduleShow` also returns newly added performance data
{{{
public class ScheduleShow {
	...
	@Out(3)
	Map<String, Performance> performancesMap = new HashMap<String, Performance>();
}

...
		return new ScheduleShowResult("", KeyFactory.keyToString(theaterKey),
				performancesMap);
}}}

`LandingView` can display performances...
{{{
	@UiField
	HTML performancesContainer;

	public void addPerformances(Map<String, Performance> performanceMap) {
		Iterator<String> i = performanceMap.keySet().iterator();
		String key;
		while (i.hasNext()) {
			key = i.next();
			performancesContainer.setHTML(performancesContainer.getHTML()
					+ "<br/>" + performanceMap.get(key).showName + " | "
					+ performanceMap.get(key).locationName + " | "
					+ performanceMap.get(key).date.toString());

		}

	}

	public void setPerformances(Map<String, Performance> performanceMap) {
		performancesContainer.setHTML("Show | Location | Date");

		addPerformances(performanceMap);

	}
}}}

...as instructed by `LandingPresenter`
{{{
	public void requestPerformances() {
		if (!(null == clientState.currentTheaterKey || clientState.currentTheaterKey
				.isEmpty())) {
			dispatcher.execute(new GetPerformancesAction(
					clientState.currentTheaterKey),
					new DispatchCallback<GetPerformancesResult>() {
						@Override
						public void onSuccess(GetPerformancesResult result) {
							if (!result.getErrorText().isEmpty()) {
								// TODO have a general handler for this
								Window.alert(result.getErrorText());
								return;
							}
							getView().setPerformances(
									result.getPerformancesMap());
						}
					});
		}

	}


	...

		if (clientState.userInfo.isSignedIn) {
			...
			requestPerformances();
		}


}}}

<img src="http://gwt-gae-book.googlecode.com/svn/wiki/images/made_in_romania7.jpg" border="0"  align="right" />

= Advanced use cases =

For the sake of example, let's consider some use cases which aren't really needed by Culture Shows, but might make sense in a larger app:
 * working with millions of entity items
 * pagination (either in the form of prev/next pages or [http://ui-patterns.com/patterns/ContinuousScrolling continuous] / [http://www.infinite-scroll.com/ infinite] scrolling)
 * sorting
 * filtering
 * collaboration (changes made by others should appear real-time to current user)
 * offline usage

= Exercise =

Think what are the issues of the basic solution and how could it be enhanced to support the use cases above.

= Enhancing the basic solution =

TODO

When we have millions of items, we definitely need to load on client only small chunks of these, depending on what the user wants to see (consider pagination, sorting, filtering).


When adding/updating/deleting items, send changes from client to server and receive back full data from server for the current client view (considering pagination, sorting, filtering). It solves the issues above, but it transfers too much data on each request.


If multiple users would work on same entity, we won't see other users changes until a full page refresh. 


How Google Docs solved collaboration: [http://googledocs.blogspot.com/2010/09/whats-different-about-new-google-docs.html challenges], [http://googledocs.blogspot.com/2010/09/whats-different-about-new-google-docs_22.html operational transformation], [http://googledocs.blogspot.com/2010/09/whats-different-about-new-google-docs_23.html collaboration protocol]. The difference to GWT is that the client has only a fragment of all the dataset, while a Google Docs client always has the full dataset (the document).

offline usage



<wiki:comment>NAV_START</wiki:comment>
<a href='http://code.google.com/p/gwt-gae-book/issues/entry'><img src='http://gwt-gae-book.googlecode.com/svn/wiki/assets/envelope.png' border='0' title='Send feedback' /></a>
<img src='http://gwt-gae-book.googlecode.com/svn/wiki/assets/spacer.png' border='0' />
<a href='http://code.google.com/p/gwt-gae-book/wiki/StoringData'><img src='http://gwt-gae-book.googlecode.com/svn/wiki/assets/prev.png' border='0' title='Previous chapter: Saving schedule in datastore' /></a>
<a href='http://code.google.com/p/gwt-gae-book/wiki/TableOfContents'><img src='http://gwt-gae-book.googlecode.com/svn/wiki/assets/contents.png' border='0' title='Table Of Contents' /></a>
<a href='http://code.google.com/p/gwt-gae-book/wiki/Authentication'><img src='http://gwt-gae-book.googlecode.com/svn/wiki/assets/next.png' border='0' title='Next chapter: Authentication with OpenID' /></a>
<wiki:comment>NAV_END</wiki:comment>