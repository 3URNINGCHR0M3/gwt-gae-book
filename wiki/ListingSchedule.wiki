#summary Listing saved schedule

<wiki:toc max_depth="2" />

Until now, we used the local datastore viewer to see what data is saved. Well, it's time to let Violeta see it too.

= A quick, basic solution =
Our basic need is to have a client doing [http://en.wikipedia.org/wiki/Create,_read,_update_and_delete CRUD] operations on Performance entity items. We just covered Create, moving on to Read.

In order to quickly get the latest schedule data and display it on client, we can 
 # get all items when page loads
 # when adding/updating/deleting items, send changes from client to server and if response is successful update the client list too

== Exercise ==
Implement listing added performances. Hints:
 * remember [ClientServer#Summary client-server communication]
 * no need to check access, performances are public
 * use a HTMLPanel to display data. We'll enhance this later

== Exercise solution ==
Added [http://code.google.com/p/gwt-gae-book/source/browse/trunk/CultureShows/src/org/gwtgaebook/CultureShows/shared/dispatch/GetPerformances.java GetPerformances] Action/Result generator, and [http://code.google.com/p/gwt-gae-book/source/browse/trunk/CultureShows/src/org/gwtgaebook/CultureShows/server/dispatch/GetPerformancesHandler.java GetPerformancesHandler]

`ScheduleShow` also returns newly added performance data
{{{
public class ScheduleShow {
	...
	@Out(3)
	String performanceKey;

	@Out(4)
	Performance performance;
}

...
		return new ScheduleShowResult("", KeyFactory.keyToString(theaterKey),
				KeyFactory.keyToString(performanceKey), performance);
}}}

`LandingView` can display performances...
{{{
	@UiField
	HTML performancesContainer;

	public void addPerformance(Performance performance) {
		performancesContainer.setHTML(performancesContainer.getHTML() + "<br/>"
				+ performance.showName + " | " + performance.locationName
				+ " | " + performance.date.toString());

	}

	public void setPerformances(List<Performance> performances) {
		performancesContainer.setHTML("Show | Location | Date");
		for (Performance p : performances) {
			addPerformance(p);
		}

	}
}}}

...as instructed by `LandingPresenter`
{{{
	protected void onReset() {
		super.onReset();
		getView().resetAndFocus();

		if (!(null == Cookies.getCookie(Constants.theaterCookieName) || Cookies
				.getCookie(Constants.theaterCookieName).isEmpty())) {
			dispatcher.execute(new GetPerformancesAction(Cookies
					.getCookie(Constants.theaterCookieName)),
					new DispatchCallback<GetPerformancesResult>() {
						@Override
						public void onSuccess(GetPerformancesResult result) {
							getView().setPerformances(result.getPerformances());
						}
					});
		}

	}

	public void scheduleShow(Date date, String showName, String locationName) {
		dispatcher.execute(new ScheduleShowAction(Cookies
				.getCookie(Constants.userTokenCookieName), Cookies
				.getCookie(Constants.theaterCookieName), date, showName,
				locationName), new DispatchCallback<ScheduleShowResult>() {
			@Override
			public void onSuccess(ScheduleShowResult result) {
				Cookies.setCookie(Constants.theaterCookieName, result
						.getTheaterKeyOut());
				getView().addPerformance(result.getPerformance());
			}
		});
	}

}}}

= Advanced use cases =

For the sake of example, let's consider some use cases which aren't really needed by Culture Shows, but might make sense in a larger app:
 * working with millions of entity items
 * pagination (either in the form of prev/next pages or [http://ui-patterns.com/patterns/ContinuousScrolling continuous] / [http://www.infinite-scroll.com/ infinite] scrolling)
 * sorting
 * filtering
 * collaboration (changes made by others should appear real-time to current user)
 * offline usage

= Exercise =

Think what are the issues of the basic solution and how could it be enhanced to support the use cases above.

= Enhancing the basic solution =

TODO

When we have millions of items, we definitely need to load on client only small chunks of these, depending on what the user wants to see (consider pagination, sorting, filtering).


When adding/updating/deleting items, send changes from client to server and receive back full data from server for the current client view (considering pagination, sorting, filtering). It solves the issues above, but it transfers too much data on each request.


If multiple users would work on same entity, we won't see other users changes until a full page refresh. 


How Google Docs solved collaboration: [http://googledocs.blogspot.com/2010/09/whats-different-about-new-google-docs.html challenges], [http://googledocs.blogspot.com/2010/09/whats-different-about-new-google-docs_22.html operational transformation], [http://googledocs.blogspot.com/2010/09/whats-different-about-new-google-docs_23.html collaboration protocol]

 offline usage.



<img src="http://gwt-gae-book.googlecode.com/svn/wiki/assets/envelope.png" border="0"  /><a href="http://code.google.com/p/gwt-gae-book/issues/entry">Send feedback</a>