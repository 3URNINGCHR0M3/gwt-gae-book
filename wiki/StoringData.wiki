#summary Saving schedule in datastore

<wiki:toc max_depth="2" />

Time to add some functionality! 


= Coding our data model =
*Pre-requisites*

 * [http://code.google.com/p/twig-persist/wiki/Quickstart Quickstart with twig-persist], an Object Datastore for Google App Engine
 * [http://code.google.com/p/twig-persist/wiki/Configuration Creating a Data Model]
 * [http://code.google.com/p/twig-persist/source/browse/src/test/java/com/google/code/twig/festival/MusicFestivalTestCase.java twig unit tests] to see more usage examples


<img src="http://gwt-gae-book.googlecode.com/svn/wiki/images/bale_of_hay.jpg" border="0"  align="right" />

Remember [DataModeling our data modeling] ? Let's code it!

*Theater.java*
{{{
package org.gwtgaebook.CultureShows.shared.model;

public class Theater {
	public String name;
	public String websiteURL;
	public String photoURL;
	public String phone;
	public String locality;
	public String region;
	public String countryName;
	public String language;
}
}}}

*Show.java* 
{{{
package org.gwtgaebook.CultureShows.shared.model;

public class Show {
	public String name;
	public String websiteURL;
	public int minuteDuration;
	...
}
}}}

Here are [http://code.google.com/p/gwt-gae-book/source/browse/trunk/CultureShows/src/org/gwtgaebook/CultureShows/shared/model/ complete data models], explained in more detail below.

= Basic data storage =
In our server handler, we'll do
{{{
import com.google.appengine.api.datastore.Key;
import com.google.code.twig.*;
import com.google.code.twig.annotation.*;
...
		Show show = new Show();
		show.name = action.getShowName();

		ObjectDatastore ds = new AnnotationObjectDatastore();
		Key showKey = datastore.store(show);
}}}

After scheduling a show, go to [http://127.0.0.1:8888/_ah/admin your local datastore viewer] and check that it has been saved. Besides data model fields (name, websiteURL), you'll see two more fields, [http://code.google.com/appengine/docs/python/datastore/keysandentitygroups.html Key and ID/Name].

= Preparing for full implementation =
Shows belong to Theaters. In a regular app, we would have asked Violeta to perform the following steps:
 * sign up
 * create a theater and specify theater details such as name, website URL
 * define shows and locations assigned to the theater defined above
 * and at last, schedule a show performance

We can do better! We're simply asking Violeta to schedule a show. If she decides to sign in, we'll preserve the data for her. We'll take care of the details behind the scenes (pun intended :-), even though that's more work for us, the engineers.

<img src="http://gwt-gae-book.googlecode.com/svn/wiki/images/rencontres-2.jpg" border="0"  align="left" />

== Exercise ==

Think for 5 minutes how we can make this work.


== Exercise solution ==

One solution would be to store all data on the client until Violeta signs in. One way to store it would be directly in GWT, but we'd lose it all on a page refresh. Another way to store it would be using [http://php-html.net/tutorials/html5-local-storage-guide/ HTML5 web storage] or even cookies since the data amount is small.

Another alternative would be to store data on server by creating entities as soon as they are needed, e.g. create a Member entity with a random user id. We would use a cookie to link server stored data to current anonymous user session. On sign in, assign these entities to the authenticated user.

We'll go with the server solution, as we need to write that code anyway. It will also work on older browsers. We need to be careful to have a script ran periodically which cleans up saved data assigned to anonymous users.

Let us write down some [http://en.wikipedia.org/wiki/Pseudocode pseudocode] of how `ScheduleShowHandler` would work when we'll have full functionality:


{{{
//data received from client: userToken, theaterKey, date, showName, locationName
//userToken - random token set by client for users not signed it

anonymous = (AppEngineUser is not signed in)

if (anonymous) {
	userId = "anonymous-" + userToken
	//prefix prevents client setting valid user IDs and overwriting their data
	//issue: client can overwrite any anonymous user data by setting a matching RandomToken. That's ok. 
} else {
	userId = AppEngineUser.getId()
}

// setup member
if there are existing members with userId {
	load member
} else {
	store new member
}

// setup theater
if (theaterKey is not empty) {
	load theater //might not exist, key may be invalid
	if (null == theater) {
		theaterKey = null	
	} else {
		verify memberKey has access to theater, exception if not
	}
}

if (theaterKey is empty) {
	create theater instance
	theaterKey = store(theater)
	assign member to theater with role administrator
}

// setup show
showKey = find(showName assigned to theaterKey)
if (showKey is empty) {
	create and store show with parent=theater 
}

//same with location

store(performance)

return theaterKey, ...
}}}



Before going the rest of the code, let's talk about...

== Datastore setup ==
<img src="http://gwt-gae-book.googlecode.com/svn/wiki/images/road_home.jpg" border="0"  align="right" />

By default, twig creates indexes for every entity property, which makes it very usable with no configuration. We'll follow the [http://code.google.com/p/twig-persist/wiki/Performance twig performance advice] and [http://code.google.com/p/gwt-gae-book/source/browse/trunk/CultureShows/src/org/gwtgaebook/CultureShows/server/AnnotationObjectDatastoreProvider.java set properties to be un-indexed by default], specifically annotating each desired property to be indexed. Our updated data model looks like this

`Show.java`
{{{
public class Show {
	private String name;

	@Index
	public String nameQuery;
	// used in queries. It's always trim and lowercase

	public String websiteURL;
	public int minuteDuration;
	public String posterURL;

	public void setName(String name) {
		this.name = name;
		nameQuery = name.trim().toLowerCase();
	}

	public String getName() {
		return name;

	}
}
}}}


We'll also [http://code.google.com/p/gwt-gae-book/source/browse/trunk/CultureShows/src/org/gwtgaebook/CultureShows/server/MainHandlerModule.java shorten kind names], which means less stored data and increases readability in datastore viewer.

Since we'll use the show name in case-insensitive queries, we're storing a copy of name property which is always trimmed and lowercased. 

== One-to-Many relationships ==
<img src="http://gwt-gae-book.googlecode.com/svn/wiki/images/bouldersbeach.jpg" border="0"  align="right" />

(Datastore relationships, that is :)

In a relational database, we would do it like this:
{{{
CREATE TABLE theater (
	key INTEGER PRIMARY KEY,
	name VARCHAR(128)
);

CREATE TABLE show (
	key INTEGER PRIMARY KEY,
	theaterKey INTEGER REFERENCES theater (key),
	name VARCHAR(128)
);
}}}

There are several alternatives to implement One-to-Many [http://code.google.com/appengine/docs/java/datastore/relationships.html relationships in AppEngine] and [http://code.google.com/p/twig-persist/wiki/Configuration#Parent-Child_Relationships twig].

We'll take advantage of [http://code.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/Key.html Keys] being able to [http://code.google.com/appengine/docs/java/datastore/creatinggettinganddeletingdata.html#Keys contain a reference to parent entity] and that [http://code.google.com/appengine/docs/java/datastore/queriesandindexes.html#Queries_on_Keys Keys can be queried]. We can leave our data models as they are, and use them like this
{{{
//store shows belonging to a theater
showKey = datastore.store().instance(show).parent(theater).now();

//query for shows belonging to a theater instance
List<Show> shows = datastore.find().type(Show.class).ancestor(theater).returnAll().now();
}}}

Coming back to the relational database analogy, the theaterKey reference is embedded in Show key `parentKey` property. !AppEngine keys are always indexed, even if we disabled indexing for class properties (TODO: is this correct?)


== Many-to-Many relationships ==

In a relational database, we would do it like this:
{{{
CREATE TABLE member (
	key INTEGER PRIMARY KEY,
	email VARCHAR(128)
);

CREATE TABLE theaterMember (
	theaterKey INTEGER REFERENCES theater (key),
	memberKey INTEGER REFERENCES member (key),
	role INTEGER NOT NULL,
	PRIMARY KEY (theaterKey, memberKey)
);
}}}


We'll go with the same approach as in relational databases and then optimize it for !AppEngine by [http://en.wikipedia.org/wiki/Database_normalization denormalizing]. 

Let's create a new entity, `TheaterMemberJoin` 
{{{
public class TheaterMemberJoin {
	public enum Role {
		ADMINISTRATOR, ARTIST, ASSISTANT
	};

	@Index
	public String theaterKey;
	@Index
	public String memberKey;
	@Index
	public Role role;
}
}}}


To add a Member to a Theater, we need just one query on `TheaterMemberJoin`.

This enables us to answer the two basic questions
 * what Members does a Theater have and with what roles?
 * what Theaters is a Member part of?

However, to display a list of Members for a Theater, we need to
 * run a query to get all member keys and roles
 * for each member, run a query to get its details

If we consider that we actually don't need ALL Member information in thist list, and storage is cheap, we can optimize reading by denormalizing our model and storing a part of Member data in the Join model. We need email and name to get a Member listing, so let's add them
{{{
public class TheaterMemberJoin {
	...
	// denormalized
	public String theaterName;

	public String memberName;
	public String memberEmail;
}
}}}

Now getting a list of Members for a Theater is one query, adding a Member to a Theater is still one write, but changing a Member email requires two writes. We don't do that often, so we're good.

When thinking how to implement your models, consider if you are doings reads often than writes and make the choices that are best for your project. If you are doing way many more readings than updates, consider storing a list of Members desired properties embedded in the Theater model. You will need two writes for a Member property update in this case.

Hopefully we'll have lots of read requests for Performances, so there too we'll keep copies of Show and Location properties.

*Resources*
 * [http://blog.arbingersys.com/2008/04/google-app-engine-better-many-to-many.html article about many to many relationships], with [http://groups.google.com/group/google-appengine/browse_thread/thread/e9464ceb131c726f group discussion]
 * [http://stackoverflow.com/questions/1376814/listproperty-of-keys-vs-many-to-many-in-app-engine other approaches]


<img src="http://gwt-gae-book.googlecode.com/svn/wiki/images/quijote3.jpg" border="0"  align="right" />

== Hey client, remember me? ==

We need the GWT client to remember the current theater and send it with each request, so we avoid creating a new theater for every show. The theater will either be sent from server when it's created, or chosen by Violeta to work on, if she will have multiple theaters.

There are a few possibilities to store data in GWT client as a session:
 * [http://stackoverflow.com/questions/1382088/session-id-cookie-in-gwt-rpc use server sessions], and persist sessions among requests. [http://groups.google.com/group/google-web-toolkit/browse_thread/thread/268ec2887bec95d2/ full sample]
 * use a static variable. It will be lost when users refresh page.
 * use HTML5 web storage
 * use cookies

For remembering the current theater, we'll go with simplest solution: a cookie. We'll use the same solution to remember the anonymous users between server calls.

`ScheduleShow.java` Action and Result generator
{{{
public class ScheduleShow {
	@In(1)
	String userToken;

	@In(2)
	String theaterKey;

	@In(3)
	String showName;

	@Out(1)
	String errorText; // empty if success

	@Out(2)
	String theaterKeyOut;

}
}}}

`LandingPresenter.java`
{{{
		dispatcher.execute(new ScheduleShowAction(Cookies
				.getCookie(Constants.userTokenCookieName), Cookies
				.getCookie(Constants.theaterCookieName), showName),
				new DispatchCallback<ScheduleShowResult>() {
					@Override
					public void onSuccess(ScheduleShowResult result) {
						...
						Cookies.setCookie(Constants.theaterCookieName, result
								.getTheaterKeyOut());
					}
				});

}}}

= Implementation =

Here are the relevant parts from `ScheduleShowHandler`, see code repository for [http://code.google.com/p/gwt-gae-book/source/browse/trunk/CultureShows/src/org/gwtgaebook/CultureShows/server/dispatch/ScheduleShowHandler.java full latest source].
{{{
		// authentication
		// TODO anonymous = (AppEngineUser is not signed in)

		if (anonymous) {
			userId = "anonymous-" + action.getUserToken();
			// prefix prevents client setting valid user IDs and overwriting
			// their data
			// issue: client can overwrite any anonymous user data by setting a
			// matching RandomToken. That's ok.
		} else {
			// TODO set userId
		}

		// setup member
		// does this member already exist?
		List<Member> members = datastore.find().type(Member.class).addFilter(
				"userId", FilterOperator.EQUAL, userId).returnAll().now();
		if (members.size() > 0) {
			// TODO log error if size != 1
			member = members.get(0);
			memberKey = datastore.associatedKey(member);
		} else {
			// store member
			// TODO if signed in, fill email, language...
			member = new Member();
			member.userId = userId;
			memberKey = datastore.store(member);

		}

		// setup theater
		if (!(null == action.getTheaterKey() || action.getTheaterKey()
				.isEmpty())) {
			// theaterKey sent by client is not empty
			try {
				theaterKey = KeyFactory.stringToKey(action.getTheaterKey());
			} catch (Exception e) {
				// invalid key, ignore it
			}
		}

		if (null != theaterKey) {
			theater = datastore.load(theaterKey);
			if (null == theater) {
				theaterKey = null;
			} else {
				// verify member has access to theater with role allowing
				// performance scheduling
				List<TheaterMemberJoin> tmjs = datastore.find().type(
						TheaterMemberJoin.class).addFilter("theaterKey",
						FilterOperator.EQUAL,
						KeyFactory.keyToString(theaterKey)).addFilter(
						"memberKey", FilterOperator.EQUAL,
						KeyFactory.keyToString(memberKey)).returnAll().now();
				if (tmjs.size() > 0) {
					// has access
				} else {
					return new ScheduleShowResult(
							"You don't have access to this theater", "");
				}

			}
		}

		if (null == theaterKey) {
			theater = new Theater();

			theater.name = "My Theater";
			// store creates a Key in the datastore and keeps it in the
			// ObjectDatastore associated with this theater instance. Basically,
			// every OD has a Map<Object, Key> which is used to look up the Key
			// for every operation.
			theaterKey = datastore.store(theater);

			// assign member to theater
			tmj = new TheaterMemberJoin();
			tmj.theaterKey = KeyFactory.keyToString(theaterKey);
			tmj.memberKey = KeyFactory.keyToString(memberKey);
			tmj.role = Role.ADMINISTRATOR;

			tmj.theaterName = theater.name;
			tmj.memberEmail = member.email;
			tmj.memberName = member.name;

			datastore.store(tmj);
		}

		// setup show
		// does show already exist?
		show = new Show();
		show.setName(action.getShowName());

		List<Show> shows = datastore.find().type(Show.class).ancestor(theater)
				.addFilter("nameQuery", FilterOperator.EQUAL, show.nameQuery)
				.returnAll().now();
		if (shows.size() > 0) {
			// TODO log error if size != 1
			show = shows.get(0);
			showKey = datastore.associatedKey(show);
		} else {
			// store show belonging to a theater
			showKey = datastore.store().instance(show).parent(theater).now();
		}

		// TODO setup location

		// setup performance
		performance = new Performance();

		performance.showKey = KeyFactory.keyToString(showKey);

		performance.theaterKey = KeyFactory.keyToString(theaterKey);
		performance.showName = show.getName();
		performance.showWebsiteURL = show.websiteURL;
		performanceKey = datastore.store(performance);

}}}


= Exercise =
Enhance performances to store not only shows, but also locations and date. 

= Exercise solution =
See [http://code.google.com/p/gwt-gae-book/source/detail?r=304 adding location source revision].


= Resources =
 * [http://code.google.com/appengine/docs/java/datastore/ App Engine Datastore Java API]
 * [http://borglin.net/gwt-project/?page_id=604  A comparison of persistence frameworks]  for App Engine, [http://code.google.com/p/twig-persist/wiki/Comparison another comparison]


<wiki:comment>NAV_START</wiki:comment>
<a href='http://code.google.com/p/gwt-gae-book/issues/entry'><img src='http://gwt-gae-book.googlecode.com/svn/wiki/assets/envelope.png' border='0' alt='Send feedback' /></a>
<img src='http://gwt-gae-book.googlecode.com/svn/wiki/assets/spacer.png' border='0' alt='' />
<a href='http://code.google.com/p/gwt-gae-book/wiki/ClientServer'><img src='http://gwt-gae-book.googlecode.com/svn/wiki/assets/prev.png' border='0' alt='Previous chapter: Client-server communication' /></a>
<a href='http://code.google.com/p/gwt-gae-book/wiki/TableOfContents'><img src='http://gwt-gae-book.googlecode.com/svn/wiki/assets/contents.png' border='0' alt='Table Of Contents' /></a>
<a href='http://code.google.com/p/gwt-gae-book/wiki/ListingSchedule'><img src='http://gwt-gae-book.googlecode.com/svn/wiki/assets/next.png' border='0' alt='Next chapter: Listing saved schedule' /></a>
<wiki:comment>NAV_END</wiki:comment>